// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Merchant {
  id                  String         @id @default(cuid())
  business_name       String
  email               String         @unique
  phone_number        String         @unique
  country             String
  settlement_currency String
  password            String
  status              MerchantStatus @default(pending_verification)
  api_key             String?        @unique
  webhook_url         String?
  created_at          DateTime       @default(now())
  updated_at          DateTime       @updatedAt
  otps                OTP[]
  settlements         Settlement[]
  kyc                 MerchantKYC?
  webhookLogs         WebhookLog[]
  payments            Payment[]
  api_key_hashed     String?        @unique
  api_key_last_four  String?
  webhook_secret     String?
  bankAccount         BankAccount?
  subscriptions       MerchantSubscription[]
}

model Plan {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  amount      Decimal  @db.Decimal(20, 7)
  currency    String   @default("USD")
  interval    BillingInterval
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
  subscriptions MerchantSubscription[]
}

model MerchantSubscription {
  id                String            @id @default(cuid())
  merchant          Merchant          @relation(fields: [merchantId], references: [id])
  merchantId        String
  plan              Plan              @relation(fields: [planId], references: [id])
  planId            String
  status            SubscriptionStatus @default(active)
  billing_cycle     BillingInterval
  current_period_start DateTime
  current_period_end   DateTime
  next_billing_date   DateTime
  created_at        DateTime          @default(now())
  updated_at        DateTime          @updatedAt

  @@unique([merchantId, planId])
  @@index([next_billing_date])
  @@index([merchantId])
}

model BankAccount {
  id             String   @id @default(cuid())
  merchant       Merchant @relation(fields: [merchantId], references: [id])
  merchantId     String   @unique
  account_name   String
  account_number String
  bank_name      String
  bank_code      String?
  currency       String
  country        String
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt
}

model OTP {
  id         String     @id @default(cuid())
  merchant   Merchant   @relation(fields: [merchantId], references: [id])
  merchantId String
  channel    OTPChannel
  code       String
  expires_at DateTime
  created_at DateTime   @default(now())

  @@unique([merchantId, channel])
}

model Settlement {
  id               String           @id @default(cuid())
  merchant         Merchant         @relation(fields: [merchantId], references: [id])
  merchantId       String
  // USDC gross amount received
  usdc_amount      Decimal
  // Fiat gross before fees
  amount           Decimal
  currency         String
  // FluxaPay settlement fee (fiat)
  fees             Decimal
  // Fiat net amount transferred to merchant
  net_amount       Decimal
  status           SettlementStatus @default(pending)
  breakdown        Json?
  // Exchange / payout partner details
  exchange_partner String?
  exchange_rate    Decimal?
  exchange_ref     String?
  // Bank transfer / payout reference
  bank_transfer_id String?
  // payment IDs included in this batch (JSON array of strings)
  payment_ids      Json             @default("[]")
  scheduled_date   DateTime
  processed_date   DateTime?
  failure_reason   String?
  created_at       DateTime         @default(now())
  updated_at       DateTime         @updatedAt
  payments         Payment[]
}

model MerchantKYC {
  id                           String           @id @default(cuid())
  merchant                     Merchant         @relation(fields: [merchantId], references: [id])
  merchantId                   String           @unique
  business_type                BusinessType
  legal_business_name          String
  business_registration_number String?
  country_of_registration      String
  business_address             String
  director_full_name           String
  director_email               String
  director_phone               String
  government_id_type           GovernmentIdType
  government_id_number         String
  kyc_status                   KYCStatus        @default(not_submitted)
  rejection_reason             String?
  reviewed_at                  DateTime?
  reviewed_by                  String?
  documents                    KYCDocument[]
  created_at                   DateTime         @default(now())
  updated_at                   DateTime         @updatedAt
}

model KYCDocument {
  id            String       @id @default(cuid())
  kyc           MerchantKYC  @relation(fields: [kycId], references: [id])
  kycId         String
  document_type DocumentType
  file_name     String
  file_url      String
  public_id     String
  file_size     Int
  mime_type     String
  created_at    DateTime     @default(now())
  updated_at    DateTime     @updatedAt
}

model WebhookLog {
  id              String                @id @default(cuid())
  merchant        Merchant              @relation(fields: [merchantId], references: [id])
  merchantId      String
  event_type      WebhookEventType
  endpoint_url    String
  http_status     Int?
  status          WebhookStatus
  payment_id      String?
  retry_count     Int                   @default(0)
  max_retries     Int                   @default(5)
  next_retry_at   DateTime?
  request_payload Json?
  response_body   String?
  created_at      DateTime              @default(now())
  updated_at      DateTime              @updatedAt
  retryAttempts   WebhookRetryAttempt[]
}

model WebhookRetryAttempt {
  id             String     @id @default(cuid())
  webhookLog     WebhookLog @relation(fields: [webhookLogId], references: [id])
  webhookLogId   String
  attempt_number Int
  http_status    Int?
  response_body  String?
  error_message  String?
  created_at     DateTime   @default(now())
}

model Payment {
  id                      String      @id @default(cuid())
  merchant                Merchant    @relation(fields: [merchantId], references: [id])
  merchantId              String
  order_id                String?     @unique // Added for search/tracking
  amount                  Decimal
  currency                String
  customer_email          String
  metadata                Json
  expiration              DateTime
  status                  String
  checkout_url            String
  timeline                Json?       // Added to track payment events
  
  // Stellar address for this payment
  stellar_address         String?     // Derived HD wallet address
  last_paging_token       String?     // Cursor for efficient transaction polling
  
  // sweeping fields
  swept                   Boolean     @default(false)
  swept_at                DateTime?
  sweep_tx_hash           String?     // This is your Stellar transaction hash
  transaction_hash        String?     // The on-chain hash for the incoming payment

  
  // settlement fields
  settled                 Boolean     @default(false)
  settled_at              DateTime?
  settlement_ref          String?
  settlement_fiat_amount  Decimal?
  settlement_fiat_currency String?
  
  // link to settlement batch
  settlement              Settlement? @relation(fields: [settlementId], references: [id])
  settlementId            String?
  createdAt               DateTime    @default(now())

  @@index([status])
  @@index([customer_email])
  @@index([createdAt])
  @@index([stellar_address])
}

// ...existing code...

enum MerchantStatus {
  pending_verification
  active
}

enum OTPChannel {
  email
  phone
}

enum SettlementStatus {
  pending
  processing
  completed
  failed
}

enum BusinessType {
  individual
  registered_business
}

enum GovernmentIdType {
  passport
  national_id
  driver_license
}

enum KYCStatus {
  not_submitted
  pending_review
  approved
  rejected
}

enum DocumentType {
  government_id
  proof_of_business_registration
  proof_of_address
}

enum WebhookEventType {
  payment_completed
  payment_failed
  payment_pending
  refund_completed
  refund_failed
  subscription_created
  subscription_cancelled
  subscription_renewed
  settlement_completed
  settlement_failed
}

enum WebhookStatus {
  pending
  delivered
  failed
  retrying
}

enum PaymentStatus {
  pending
  confirmed
  failed
  expired
}


enum RefundStatus {
  initiated
  processing
  completed
  failed
}

enum RefundReason {
  customer_request
  duplicate_payment
  failed_delivery
  merchant_request
  dispute_resolution
}

enum BillingInterval {
  monthly
  yearly
}

enum SubscriptionStatus {
  active
  cancelled
  past_due
}

model Refund {
  id               String       @id @default(cuid())
  payment_id       String
  merchant_id      String
  amount           Decimal      @db.Decimal(20, 7)
  currency         String
  customer_address String
  reason           RefundReason
  reason_note      String?
  status           RefundStatus @default(initiated)
  stellar_tx_hash  String?
  error_message    String?
  error_code       String?
  initiated_by     String
  created_at       DateTime     @default(now())
  updated_at       DateTime     @updatedAt

  @@index([payment_id])
  @@index([merchant_id])
  @@index([status])
}
